# Breadth-First-Search：O(V+E)
> 首先從原點（source）開始，走訪與原點相鄰且未被記錄的節點進行記錄  
> 接著從這些剛被記錄的節點中挑一個節點重複進行上述動作直到走訪完整張圖

BFS 演算法可以幫助我們記錄從起點到任意一點的距離以及走訪的路線，和等等要介紹的 DFS 差異在於 BFS 會將同一層級的節點走訪完後才會前往下一層級，因此整個圖的尋訪過程是會逐漸加寬的，前面提到會走訪節點並記錄與其相鄰之節點，當一個節點被記錄時，會將此節點放入佇列（Queue），而當 BFS 要進到下一層級挑選節點時，則會從佇列選擇出要走訪的節點（FIFO）。
- Pseudocode：（BFS）

<img width="500" alt="截圖 2022-07-10 下午2 44 47" src="https://user-images.githubusercontent.com/103521272/178134318-43532f7b-b7b3-430f-8081-3517de8555c3.png">

d[] 是用來儲存節點與根節點的距離，π[] 則是用來儲存父節點，若是 π[0] = 1，表示是經過節點1才到達節點0的，color[]用來儲存節點的狀態，分為白、黑、灰，分別代表尚未走訪、走訪完畢以及正在走訪。  

首先從根節點開始走訪，標示根節點為走訪中並加入先進先出的佇列，佇列放入的為走訪中的節點。接著在 while 迴圈中，假如佇列不為空的情況下，也就是還有節點未被走訪完畢，取出佇列的第一個節點並找出其相鄰節點，若是相鄰節點尚未被走訪（白），則標示此相鄰節點為走訪中（灰）並加入佇列，而此節點的 d 、 π 分別為剛剛佇列的第一個節點的 d+1 以及剛剛佇列的第一個節點，最後當每一個相鄰節點都被確認狀態後，則將剛剛佇列的第一個節點標示為走訪完畢（黑）。

- Java：（BFS）
