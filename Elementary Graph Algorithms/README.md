# Breadth-First Search：O(V+E)
> 首先從原點（source）開始，走訪與原點相鄰且未被記錄的節點進行記錄  
> 接著從這些剛被記錄的節點中挑一個節點重複進行上述動作直到走訪完整張圖

BFS 演算法可以幫助我們記錄從起點到任意一點的距離以及走訪的路線，和等等要介紹的 DFS 差異在於 BFS 會將同一層級的節點走訪完後才會前往下一層級，因此整個圖的尋訪過程是會逐漸加寬的，前面提到會走訪節點並記錄與其相鄰之節點，當一個節點被記錄時，會將此節點放入佇列（Queue），而當 BFS 要進到下一層級挑選節點時，則會從佇列選擇出要走訪的節點（FIFO）。
- Pseudocode：（BFS）

<img width="500" alt="截圖 2022-07-10 下午2 44 47" src="https://user-images.githubusercontent.com/103521272/178134318-43532f7b-b7b3-430f-8081-3517de8555c3.png">

d[] 是用來儲存節點與根節點的距離，π[] 則是用來儲存父節點，若是 π[0] = 1，表示是經過節點1才到達節點0的，color[]用來儲存節點的狀態，分為白、黑、灰，分別代表尚未走訪、走訪完畢以及正在走訪。  

首先從根節點開始走訪，標示根節點為走訪中並加入先進先出的佇列，佇列放入的為走訪中的節點。接著在 while 迴圈中，假如佇列不為空的情況下，也就是還有節點未被走訪完畢，取出佇列的第一個節點並找出其相鄰節點，若是相鄰節點尚未被走訪（白），則標示此相鄰節點為走訪中（灰）並加入佇列，而此節點的 d 、 π 分別為剛剛佇列的第一個節點的 d+1 以及剛剛佇列的第一個節點，最後當每一個相鄰節點都被確認狀態後，則將剛剛佇列的第一個節點標示為走訪完畢（黑）。

- Java：（BFS）
<img width="500" alt="截圖 2022-07-10 下午3 15 06" src="https://user-images.githubusercontent.com/103521272/178135207-f4cd0981-39c4-41e5-91d2-533900552417.png">

Adj[] 為鄰接串列陣列（adjacency-list representation），此陣列的每一個元素代表一個 LinkedList，也就是一個節點，用來儲存與此節點相連的節點，以此方法來完成圖的實現。

以下是主程式碼以及執行結果：

<img width="500" alt="截圖 2022-07-10 下午3 31 05" src="https://user-images.githubusercontent.com/103521272/178135533-fec3994f-bddc-48ec-9a91-e79e5576b876.png">

<img width="500" alt="截圖 2022-07-10 下午3 31 52" src="https://user-images.githubusercontent.com/103521272/178135547-8d4578c7-07da-4606-844f-3a7087059d70.png">

# Depth-First-Search：O(V+E)
> 首先從原點（source）開始，挑選一個未被記錄的相鄰節點進行遞迴呼叫 DFS-visit
> 當遞迴停止表示從此相鄰節點延伸出的路線已無法再加深，接著挑選下一個未被記錄的相鄰節點進行遞迴呼叫 DFS。
> 之後依此類推直到確認過每一個相鄰節點，若是在 DFS-visit 後仍存在未被走訪的節點，則會因為 DFS 的呼叫而走訪到

DFS 的特點在於尋訪相鄰節點時，並不會像 BFS 一樣尋訪完同一層級的所有相鄰節點才進到下一層，而是在尋訪其中一個相鄰節點時繼續尋訪此節點的相鄰節點，直到此路線到達盡頭後才繼續走訪同一層級的其他相鄰節點，在底下的程式實作以及虛擬碼中也會紀錄節點開始走訪的時間以及結束走訪的時間，而在後面要介紹的兩種演算法則是從 DFS 的特性延伸出來的。

- Pseudocode：（DFS）

<img width="500" alt="截圖 2022-07-10 下午4 15 49" src="https://user-images.githubusercontent.com/103521272/178136938-78e6c0cd-bbba-4f57-82a1-9578ffb0b13b.png">

d[] 是用來儲存開始走訪的時間，f[]是用來儲存走訪完畢的時間，π[] 則是用來儲存父節點，若是 π[0] = 1，表示是經過節點1才到達節點0的，color[]用來儲存節點的狀態，分為白、黑、灰，分別代表尚未走訪、走訪完畢以及正在走訪。  

DFS 會檢查每一個節點，若是節點尚未被走訪，則對此節點執行 DFS-visit，此方法確保圖中的每一個節點都能被走訪到。首先對第一個節點執行 DFS-visit，將此節點標示為正在走訪並記錄其開始走訪的時間，接著找出未被尋訪的相鄰節點執行 DFS-visit，當此相鄰節點所延伸出的路線到達盡頭，則找下一個未被尋訪的相鄰節點執行 DFS-visit，依此類推，當相鄰節點都檢查完時，則將此節點標示為走訪完畢並記錄完成走訪時間。接著又會回到 DFS 的 for 迴圈，若是存在節點是剛剛第一個節點延伸出的路線中未被尋訪到的，則此 for 迴圈會找出此節點並執行 DFS-visit，直到所有節點被檢查完後演算法執行結束。


- Java：（DFS）

<img width="500" alt="截圖 2022-07-10 下午4 17 11" src="https://user-images.githubusercontent.com/103521272/178136981-701cec45-a29c-44a8-b31a-29c7d2e16cc3.png">

和 BFS 一樣，Adj[] 為鄰接串列陣列（adjacency-list representation），此陣列的每一個元素代表一個 LinkedList，也就是一個節點，用來儲存與此節點相連的節點。

以下是主程式碼以及執行結果：

<img width="500" alt="截圖 2022-07-10 下午5 01 24" src="https://user-images.githubusercontent.com/103521272/178138295-3dad26e0-fc77-4438-a71a-b01cfb956f24.png">

<img width="" alt="截圖 2022-07-10 下午5 01 54" src="https://user-images.githubusercontent.com/103521272/178138302-bec4b38a-f6c5-47e8-8335-2489ea368ca3.png">
