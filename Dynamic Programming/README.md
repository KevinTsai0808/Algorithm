# Dynamic Programming
動態規劃的核心概念就是將原問題分解成數個子問題以解決原本複雜的問題，每一次計算子問題時都會儲存計算的答案，因此相較於貪婪演算法省去了許多重複計算的時間，而這些子問題的解會被用來解決規模更大的子問題，最後解決原題。

動態規劃最困難的地方在於看到題目時如何想出原問題與子問題的關係並加以寫出通式。  以下會介紹四種動態規劃常見的題目：
1. 裝配線調度問題（Assembly-Line Scheduling）
2. 矩陣鏈相乘問題（Matrix Chain Multiplication）
3. 最長共同子序列（Longest Common Subsequence）
4. 0-1背包問題（0-1 Knapsack）

# Assembly-Line Scheduling
>一個工廠有兩條裝配線，而每一條裝配線都各有 i 個工作站，當一個產品要被製造時必須經過每一個工作站以完成製作  
>然而由於加工的方法不同，因此同一個工作站下，兩條裝配線會有不同的加工時間，從一條裝配線轉移至另一條裝配線也會有轉換時間  
>因此必須思考哪一個工作站要於哪個一條裝配線加工以最小化產品製作時間

若是利用遍歷的方法進行解題，則整個演算法所需時間會高達 O(2^n)，因此利用動態規劃的方式進行解題。  
我們可以發現在每一次加工前，產品會從兩個方向抵達目前的工作站：
1. 同一條裝配線
2. 從另一條裝配線轉移

因此分別計算出兩種方向的時間成本並進行比較，就可以得出抵達目前工作站所需的最小時間成本，再利用目前算出的最佳解進行下一個工作站的成本計算，透過此方法，在計算下一個工作站時，不需從第一個工作站慢慢計算，只需要取得目前工作站的最佳解再加上下一個工作站的加工時間、轉換時間便可求出答案，以下是關係式：

<img width="500" alt="截圖 2022-07-04 下午6 06 58" src="https://user-images.githubusercontent.com/103521272/177132995-7c31108b-fe28-4716-abaf-0ca05d394767.png">

f1[]、f2[]儲存的是到 j 工作站的最小時間成本，e1、e2代表前置時間，也就是到第一個工作站前的時間成本，aij則表示第 i 個裝配線第 j 個工作站的加工時間，tij則表示第 i 個裝配線第 j 個工作站轉移至另一個裝配線第 j+1 個工作站的轉移成本，x1、x2則表示最後一個工作站到產品完成的作業時間。

- Pseudocode：（Assembly-Line Scheduling）

<img width="500" alt="截圖 2022-07-04 下午6 19 38" src="https://user-images.githubusercontent.com/103521272/177135166-f3d9aa2f-6af9-417b-90a9-11cdeff16e82.png">
<img width="500" alt="截圖 2022-07-04 下午6 19 58" src="https://user-images.githubusercontent.com/103521272/177135218-7a2e6310-173b-4698-ac64-29684058af68.png">

- Java： （Assembly-Line Scheduling）
<img width="500" alt="截圖 2022-07-04 下午6 22 58" src="https://user-images.githubusercontent.com/103521272/177135702-10e1513d-a1df-41e8-aa79-5b591c59be0a.png">
