# Activity Selection Problem：O(nlogn)
>給予一系列的活動及他們的開始/結束時間，在時間不重疊的條件下找出可以使活動執行數量最大的策略

- Pseudocode：（Activity Selection Problem）

<img width="500" alt="截圖 2022-07-15 下午1 35 06" src="https://user-images.githubusercontent.com/103521272/179157643-90c94524-86d7-4adb-a47f-2c933830fed3.png">

在虛擬碼的 input 中可以看到分別為活動開始時間及活動結束時間，需要注意的是這裡的結束時間是已經排序好的狀態，之所以要排序結束時間的用意在於當每次迭代我們選擇了結束時間較早的活動時，就等於最大化剩餘的時間，這也是為什麼我們不會選擇排序開始時間的原因。  

從這裡也能看出貪婪演算法的性質，我們每次選擇的都是目前這個狀態的最佳解，而在滿足某些條件下，這個局部最佳解就是整體最佳解的一部分。

首先選擇排序好後的第一個活動，也就是結束時間最早的活動，接著從第二個活動開始走訪，如果第一個活動的結束時間和此活動的開始時間不衝突，則選擇此活動，接著繼續尋找與此活動的結束時間不衝突的活動，依此類推直到走訪完每個活動。

- Java：（Activity Selection Problem）

<img width="500" alt="截圖 2022-07-15 下午1 48 28" src="https://user-images.githubusercontent.com/103521272/179159249-0775eda7-6b59-47f7-8e43-53c549bd42d7.png">

# Huffman Codes：O(nlogn)
>給予一系列字元出現的頻率，希望透過 variable length code 來將這些字元進行編碼，目標是最小化使用的位元

當我們對字元進行編碼時，通常比較熟知的方式是使用固定長度的編碼方式，像是字元 a 為 001，b 為 010 等等，但如果今天有些字元出現頻率很高，有些則很少，為了減少運算資源及空間的使用，更好的做法應該是給予出現頻率較高的字元長度較短的編碼，出現頻率較低的字元則給予長度較長的編碼。

- Pseudocode：（Huffman Codes）

<img width="500" alt="截圖 2022-07-15 下午2 15 05" src="https://user-images.githubusercontent.com/103521272/179162678-17b8de82-39d0-4e80-ae68-e3958af06522.png">

首先將所有節點都加入

